import torch
import torch.nn as nn
import torch.optim as optim
from PIL import Image
from torchvision import transforms
import requests
import os

# üî¥ CHANGE THIS TO LAPTOP A'S IP!
FOG_IP = "10.107.13.39"
FOG_URL = f"http://{FOG_IP}:5000/submit_update"

class PhotoTagger(nn.Module):
    def _init_(self, num_classes=5):
        super()._init_()
        self.features = nn.Sequential(
            nn.Conv2d(3, 16, 3, padding=1),
            nn.ReLU(),
            nn.AdaptiveAvgPool2d(1)
        )
        self.classifier = nn.Linear(16, num_classes)

    def forward(self, x):
        return self.classifier(self.features(x).flatten(1))

# Label mapping - keeps consistent with your label file
LABELS = ["beach", "birthday", "cat", "dog", "food"]

def load_photo_and_label(photo_path):
    # Image loading and preprocessing
    transform = transforms.Compose([
        transforms.Resize((32, 32)),
        transforms.ToTensor(),
    ])
    img = Image.open(photo_path).convert("RGB")
    x = transform(img).unsqueeze(0)  # Add batch dim: (1, 3, 32, 32)

    # Build label file path by replacing image extension with .txt
    if photo_path.lower().endswith('.jpg') or photo_path.lower().endswith('.jpeg'):
        label_file = photo_path.rsplit('.', 1)[0] + '.txt'
    elif photo_path.lower().endswith('.png'):
        label_file = photo_path.rsplit('.', 1)[0] + '.txt'
    else:
        label_file = photo_path + '.txt'

    # Initialize default label index (dog)
    label = 3

    # Read label file safely
    if os.path.exists(label_file) and label_file != photo_path:
        try:
            with open(label_file, encoding='utf-8') as f:
                label_str = f.read().strip().lower()
            if label_str in LABELS:
                label = LABELS.index(label_str)
            else:
                print(f"‚ö† Unrecognized label '{label_str}'. Using default: {LABELS[label]}")
        except Exception as e:
            print(f"‚ö† Could not read label file: {e}. Using default: {LABELS[label]}")
    else:
        print(f"‚ö† No label file found. Using default label: {LABELS[label]}")

    y = torch.tensor([label])
    print(f"üì∏ EDGE: Loaded private photo '{os.path.basename(photo_path)}'")
    print(f"üè∑  Label: {LABELS[label]} (class {label})")
    return x, y

def train_local_model(x, y):
    model = PhotoTagger()
    optimizer = optim.SGD(model.parameters(), lr=0.01)
    loss_fn = nn.CrossEntropyLoss()

    model.train()
    for _ in range(20):
        optimizer.zero_grad()
        output = model(x)
        loss = loss_fn(output, y)
        loss.backward()
        optimizer.step()

    return model.state_dict()

def send_to_fog(weights, photo_path):
    photo_size = os.path.getsize(photo_path) / 1024  # KB
    serial = {k: v.tolist() for k, v in weights.items()}
    weight_size = len(str(serial).encode()) / 1024  # KB

    print("\n" + "="*70)
    print("üì§ EDGE: SENDING DATA TO FOG (YOUR HOME ROUTER)")
    print(f"Private photo: {os.path.basename(photo_path)} ({photo_size:.1f} KB)")
    print(f"Sending ONLY model weights: {weight_size:.1f} KB")
    print("‚úÖ PHOTO NEVER LEAVES YOUR DEVICE!")
    print("="*70 + "\n")

    try:
        resp = requests.post(FOG_URL, json=serial, timeout=10)
        print(f"‚úÖ Success! Fog responded with status {resp.status_code}")
    except Exception as e:
        print(f"‚ùå Failed to reach fog: {e}")

if _name_ == '_main_':
    photo_path = "/Users/saadhanagroup/Downloads/photo-fl/cat.jpeg"

    if not os.path.exists(photo_path):
        print(f"‚ùå Photo not found: {photo_path}")
        exit(1)

    x, y = load_photo_and_label(photo_path)
    weights = train_local_model(x, y)
    send_to_fog(weights, photo_path)
